All search algorithms stated in the project description are implemented, which are _**"BFS","DFS","UCS","GS","A*"**_,and _**"A*2"**_.

The very first heuristic function came to my mind was very simple, the number of pegs on the board. This heuristic would tend to remove as many as peg possible per move which sounds reasonable, since removing multiple pegs at one move is allowed. But later, I realized that this heuristic function is not consistent. Because the minimum possible cost of an action is 1, whereas more than one peg can be removed at one action. Thus, we cannot guarantee that _**h(n) ≤ c(n, a, n’) + h(n’)**_ will always hold where n’ is a successor of n generated by any action a.

#### **counter example:**                                                         
removing 3 pegs by moving some peg up c(n, up, n’) = 1, h(n) = x, h(n’) = x-3                     
x ≤ 1 +(x-3) is not consistent, where x is a positive number

Then, another simple idea came to my mind. If I tune the result of heuristic function to interval [0, 1], it will be always consistent. Every consistent heuristic is also admissible since consistency is stricter requirement (Sec3.5, page95 on our course book). Hence, this heuristic will also be admissible.

#### **Proof:**  
h(n) ≤ c(n, a, n′) + h(n’)                                             
h(n) - h(n’) ≤ c(n, a, n’)                                            
max(h(n) - h(n’)) ≤ min(c(n, a, n’)) which is 1 ≤ 1                       
thus every h(n) ≤ c(n, a, n′) + h(n’) holds
I implemented tuning the result of heuristic function to interval [0, 1] simply dividing by size of the board which equals the sum of number of pegs and number of holes.

So, my heuristic function becomes  (number of pegs)/(number of peg+number of holes), which range is obviously [0, 1] where the number of pegs and holes are positive integer. This heuristic represents kind of peg occupancy rate on the board. 

From examination of this heuristic with given inputs, it finds the optimal solution with less removed nodes than UCS search but more removed nodes than A*. Also, it doesn’t require a complex computation which is a good sign (O(N*M) operations where N is length, M is width of the board).

> _For input1: A*2_ 				 _Number of removed nodes: 74_		       _Path cost: 4_	   _Solution: h up, g up, g right_		      
> _For input1: A*2_	         _Number of removed nodes: 10_           _Path cost: 4_    _Solution: b up, a up, b right_
